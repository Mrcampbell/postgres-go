// Code generated by gnorm, DO NOT EDIT!

package books

import (
	"database/sql"
	"time"

	"github.com/pkg/errors"
	uuid "github.com/satori/go.uuid"
	"gnorm.org/postgres-go/example/gnorm"
	"gnorm.org/postgres-go/example/gnorm/enum"
)

// Row represents a row from 'books'.
type Row struct {
	ID        int            // id (PK)
	AuthorID  uuid.UUID      // author_id
	Isbn      string         // isbn
	Booktype  enum.BookType  // booktype
	Title     string         // title
	Pages     int            // pages
	Summary   sql.NullString // summary
	Available time.Time      // available
}

// Field values for every column in Books.
var (
	IDCol        gnorm.IntField           = "id"
	AuthorIDCol  gnorm.UuidUUIDField      = "author_id"
	IsbnCol      gnorm.StringField        = "isbn"
	BooktypeCol  enum.BookTypeField       = "booktype"
	TitleCol     gnorm.StringField        = "title"
	PagesCol     gnorm.IntField           = "pages"
	SummaryCol   gnorm.SqlNullStringField = "summary"
	AvailableCol gnorm.TimeTimeField      = "available"
)

// Query retrieves rows from 'books' as a slice of Row.
func Query(db gnorm.DB, where gnorm.WhereClause) ([]*Row, error) {
	const origsqlstr = `SELECT 
		id, author_id, isbn, booktype, title, pages, summary, available
		FROM public.books WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	var vals []*Row
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID, &r.AuthorID, &r.Isbn, &r.Booktype, &r.Title, &r.Pages, &r.Summary, &r.Available)
		if err != nil {
			return nil, err
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// One retrieve one row from 'books'.
func One(db gnorm.DB, where gnorm.WhereClause) ([]*Row, error) {
	const origsqlstr = `SELECT 
		id, author_id, isbn, booktype, title, pages, summary, available
		FROM public.books WHERE (`

	idx := 1
	sqlstr := origsqlstr + where.String(&idx) + ") "

	var vals []*Row
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID, &r.AuthorID, &r.Isbn, &r.Booktype, &r.Title, &r.Pages, &r.Summary, &r.Available)
		if err != nil {
			return nil, err
		}
		vals = append(vals, &r)
	}
	return vals, nil
}

// Insert inserts the row into the database.
func Insert(db gnorm.DB, r *Row) error {
	const sqlstr = `INSERT INTO books (
			id, author_id, isbn, booktype, title, pages, summary, available
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8
		)`
	_, err := db.Exec(sqlstr, r.ID, r.AuthorID, r.Isbn, r.Booktype, r.Title, r.Pages, r.Summary, r.Available)
	return errors.Wrap(err, "insert Books")
}

// Update updates the Row in the database.
func Update(db gnorm.DB, r *Row) error {
	const sqlstr = `UPDATE books SET (
			author_id, isbn, booktype, title, pages, summary, available		
		) = ( 
			$1, $2, $3, $4, $5, $6, $7
		) WHERE
			id = $8
		`
	_, err := db.Exec(sqlstr, r.AuthorID, r.Isbn, r.Booktype, r.Title, r.Pages, r.Summary, r.Available, r.ID)
	return errors.Wrap(err, "update Books:")
}

// Upsert performs an upsert for Books.
//
// NOTE: PostgreSQL 9.5+ only
func Upsert(db gnorm.DB, r *Row) error {
	const sqlstr = `INSERT INTO books (
		author_id, isbn, booktype, title, pages, summary, available, id
	) VALUES (
		$1, $2, $3, $4, $5, $6, $7, $8
	) ON CONFLICT (id) DO UPDATE SET (
		author_id, isbn, booktype, title, pages, summary, available
	) = ( 
		$1, $2, $3, $4, $5, $6, $7
	)`

	_, err := db.Exec(sqlstr, r.AuthorID, r.Isbn, r.Booktype, r.Title, r.Pages, r.Summary, r.Available, r.ID)
	return errors.Wrap(err, "upsert Books")
}

// Delete deletes the Row from the database.
func Delete(
	db gnorm.DB,
	id int,
) error {
	const sqlstr = `DELETE FROM books WHERE id = $1`

	_, err := db.Exec(
		sqlstr,
		id,
	)
	return errors.Wrap(err, "delete Books")
}
