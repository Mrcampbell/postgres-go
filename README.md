# postgres-go

A gnorm solution for generating strongly typed database/sql wrappers for
postgres.


## Magic Strings (what most people write with other ORMs)

Do you have code in your repo that looks like this?

```go
  var product Product
  db.First(&product, "code = ?", "L1212") // find product with code l1212

  // Update - update product's price to 2000
  db.Model(&product).Update("Price", 2000)
```

Sure, it works now. What happens if you pass, say, a UUID into that first line?  It'll compile.
It'll run.. until it hits that exact line, and then it'll error out at runtime.

What happens if you typo "code" in that first line?  Again, runtime error.

What happens if you someday migrate your database and decide that "Price" should now be called
"ItemPrice"?  Runtime error.

## What your code will look like with Gnorm

Example of code using code generated by gnorm (this is the stuff you write):

```go
import "github.com/yourOrg/yourProj/models/gnorm/user"

func insert(db *sql.DB) error {
    // plain old boring struct. Look ma, no struct tags!
    u := users.Row{
        ID: uuid.NewV4(),
        Name: "Bob Smith",
        Age: 84,
        Role: enum.AdminRole,
    }
    // user.Insert takes a user.Row.  Strongly typed!
    if err := users.Insert(db, u); err != nil {
        return err
    }
}

func findOldMods(db *sql.DB) error {
    // Strongly typed queries.  Age can only be compared to an int, Role can 
    // only be compared to the Role enum type.
    mods, err := users.Query(db, gnorm.AndClause( 
        users.AgeCol.GreaterThan(40),
        users.RoleCol.In(enum.AdminRole, enum.ModeratorRole),
    ))
}
```

The best thing about this is that **if you migrate your database and re-run gnorm, you'll get *compile
time* errors** if column, table, or enum names or types have changed.  Decided you wanted to change
the `type` column on users to `user_role`?  With gnorm and postgres-go, it's no big deal, you'll get
a compile error everywhere in your data layer where you accessed it via the old name.

Not only do you get compile-time errors, but there's no reflection, so it's screaming-fast.

Gnorm lets you generate files in whatever directory structure you like, so we can use
go's package namespacing to avoid unwieldy names like db.UsersAgeCol and instead just have
users.AgeCol, without worrying about if some other table has an age column of a different type.

## What This Solution Generates

The final benefit is that gnorm generates boring old go code. This is the code you'd write, written
the way you'd write it, if you had the time and patience to do that (and if you didn't already know
about gnorm).  

```go
// Inside gnorm/users/users.go

package users

// ...

// Query retrieves rows from 'users' as a slice of Row.
func Query(db gnorm.DB, where gnorm.WhereClause) ([]*Row, error) {
	const origsqlstr = `SELECT 
		id, name, age, role
		FROM public.users WHERE (`

    idx := 1
    // the WhereClause just concatenates existing strings.  It's an interface
    // so each implmentation knows how to convert itself into a string without
    // reflection.
	sqlstr := origsqlstr + where.String(&idx) + ") "

	var vals []*Row
	q, err := db.Query(sqlstr, where.Values()...)
	if err != nil {
		return nil, err
	}
	for q.Next() {
		r := Row{}
		err := q.Scan(&r.ID, &r.Name, &r.Age, &r.Role)
		if err != nil {
			return nil, err
		}
		vals = append(vals, &r)
	}
	return vals, nil
}
```

All the functions take a gnorm.DB, which matches both sql.DB and sql.Tx, so you can easily bundle a
bunch of changes into a transaction if you want.

## TODOs

Implement joins when foreign keys land in gnorm (which will be soon!).

There's probably a lot of optimizations that could be made to the code.
Pull requests are welcome.